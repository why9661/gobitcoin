# 比特币系统学习

## 密码学原理

比特币系统主要用到了密码学的两个功能：哈希和签名。

### 哈希

比特币使用的哈希函数是SHA256。



密码学中用到的哈希函数被称为Cryptography Hash Function。

它有两个重要的性质：collision resistance、hiding。

+ collision resistance

  collision指“哈希碰撞”，即X≠Y，H(X) = H(Y)，此时就发生了哈希碰撞；因为输入空间总是会大于输出空间，所以碰撞是不可避免的。

  但是对于给出的X，很难找到Y使得H(X) = H(Y)，除非暴力破解，这就是collision resistance。

+ hiding

  hiding是指哈希函数的计算过程是单向的不可逆，即无法通过H(X)反推出X。

  hiding性质成立的前提是输入空间要足够大且分布要比较均匀，以保证通过暴力破解反推出X的方法是基本不可行的。

  

比特币中用到的哈希函数还有另一个很重要的性质：puzzle friendly。

+ puzzle friendly

  是指哈希值的计算事先是不可预测的；比如想要得到一个落在某个区间的哈希值0...0XXX，那么只能通过一个一个输入X去试没有捷径。

比特币**挖矿**的过程中实际就是找一个nonce，nonce跟区块的块头里的其他信息合一起作为输入，得出的哈希值要小于等于某个指定的目标预值。H(block header)≤target，block header 指块头，块头里有很多域，其中一个域是我们可以设置的随机数nonce，挖矿的过程是不停的试随机数，使得block header取哈希后落在指定的范围之内。

### 签名

签名是利用的非对称加密体系，A用自己的私钥进行签名，其它人用A的公钥验证签名。



签名可以保证：

1、当数据从发送方传送到接受方时，数据不会被修改

2、确保数据是由某一发送方发送的



比特币中用的签名算法（ECDSA），不仅是生成公私钥的时候要有好的随机源，之后每一次签名时也要有好的随机源。只要有一次签名用的随机源不好的话，就有可能泄露私钥。

## 数据结构

### 哈希指针

哈希指针的好处是不仅可以链接到上一个结构体，而且还能够检测结构体的内容是否被篡改。

### 区块链

比特币中最基本的结构就是区块链，区块链就是一个一个区块组成的链表。

区块链使用哈希指针，每一个区块都包含指向前一个区块的哈希指针。

一个区块的哈希值是把前面整个区块的内容，包括里面的hash pointer ，合在一起取哈希值。通过这种结构，只要保存最后一个区块的哈希就可以检测整个区块链是否被篡改。

#### 区块

区块可以分为header和body两部分。

header中包括但不限于：版本号、时间戳、前一区块的哈希、merkle tree的根哈希、随机数Nonce、挖矿难度。

body则是交易交易列表。

### Merkle Tree

每个区块包含的交易其实是组织成一棵Merkle Tree的形式。

Merkle Tree从叶子节点开始，一个叶子节点就是一个交易的哈希（比特币系统中叶子节点是双哈希即“交易的哈希的哈希”），叶子节点的数量必须是双数，如果一个区块里的交易是单数，那么就将最后一个叶子节点复制一份凑成双数。从下往上两两成对，形成一个中间节点，中间节点的值取两个节点值组合的哈希，重复这个过程直到只有一个节点（根节点），根哈希即可作为整个块交易的唯一标识。

## 节点

比特币中的节点可以分为全节点和轻节点。

### 全节点

全节点存有一份完整的、最新的区块链拷贝。全节点能够独立自主地校验所有交易，而不需借由任何外部参照。

### 轻节点（SPV）

一个轻节点想要知道某个交易是否写入到了区块链，就需要用到**merkle proof**。

## 共识机制

比特币系统中取得共识的方式是通过算力进行"投票"即工作量证明PoW。每个节点都可以在本地组装出一个候选区块，把它认为合法的交易放在里面，然后开始尝试各种nonce值，看哪一个能满足不等式H(block header)≤target的要求。如果某个节点找到了符合要求的nonce，它就获得了记账权，所谓的记账权，就是往比特币账本里写入下一个区块的权利。

共识流程：

1.每产生一个新的交易向全网广播。

2.其他节点将收到的交易信息纳入一个候选区块中，并将其他很多交易一起打包在一起。

3.其他节点都尝试在自己的候选区块中进行具有足够难度的工作量证明（POW）。

4.当某个节点完成了工作量证明（POW），向全网广播此区块的完成结果。

5.其他节点验证其完成结果。

6.其他节点若验证通过，才能将此区块添加到区块链中。

**最长合法链**

接收的区块需要扩展最长合法链。

### 激励机制

比特币中的激励机制：区块奖励&交易费。



在比特币系统中，每挖出21万个区块，区块奖励就会减半。

比特币系统设置的平均出块时间为10分钟。

每隔2016个区块(大约14天)就会调整挖矿难度

target = target * (actual time)/(expected time)   （显然挖矿难度和target是成反比的）

在实际代码中，上调和下调一次性不会超过4倍。

coinbase交易里有一个coinbase域可以写入任何内容(可以用于当挖矿难度太大导致遍历完所有的nonce都不能完成工作量证明时,修改coinbase交易里这个域的内容从而影响存储在header中的merkle tree的根哈希。块头里4个字节的nonce不够用,可以把coinbase域的一些字节作为extra nonce来用,所以真正挖矿的时候是有两层循环,外层调整coinbase里的extra nonce,内层循环再调整header里的nonce)

## 账户

在比特币系统中，一对公私钥对就代表了一个账户。

比特币系统使用**椭圆曲线**来产生私钥，使用**ECDSA算法**签名。

**地址**是用公钥经过一些转换得到的，如图：

```flow
op1=>operation: 椭圆曲线生成私钥
op2=>operation: 通过ECDSA算法生成公钥PubKey
op3=>operation: RIPEMD(SHA256(PubKey))得到PubKeyHash
op4=>operation: 将PubKeyHash拼接到Version后得到VersionedPayload
op5=>operation: 取SHA256(SHA256(VersionedPayload))的前4个字节作为Checksum
op6=>operation: 将Checksum拼接到VersionedPayload
op7=>operation: 将上一步结果进行Base58编码
op1->op2->op3->op4->op5->op6->op7
```



## 交易

+ 普通交易

  在比特币系统中，一个交易包含两部分：若干**输入**和若干**输出**。

  + 输入

    输入要说明币的来源（引用其它交易的输出）。

  + 输出

    输出要给出接收者的公钥哈希。

    

+ coinbase 交易

  铸币交易coinbase只有一个输出，里面包含了矿工的公钥哈希。

  挖矿奖励实际就是一笔coinbase交易。

  

+ UTXO

  UTXO即Unspent Transaction Output，UTXO可以快速检测double spending，判断交易是否合法。

  UTXO的每个元素需要给出产生这个输出的交易ID(哈希值)以及它在这个交易的第几个输出(index)。

## 网络

比特币系统中的底层网络是一个P2P网络，系统中的所有节点都是平等的。

### DNS Seed

返回比特币网络上完整节点IP地址的DNS服务器，用于协助发现节点。

# 附录

## 双花问题

“双花”即“double spending attack”，指的是由于数据的可复制性，使得系统中同一笔数字资产被重复使用。

## ECDSA

ECDSA即Elliptic Curve Digital Signature Algorithm。

简单来说，在由一个数学方程确定的一条曲线上随机选取一个点作为**原点**，接着产生一个随机数作为**私钥**，最后用上面的私钥和原点通过一系列复杂的数学方程得到曲线上的第二个点，这个点就是**公钥**。当要对一个文件进行**签名**时，用私钥和文件的哈希组成一个数学方程即为签名，签名分为R和S两部分，验证签名时，将公钥和S代入数学方程中得到R的话，这个签名就是有效的。

## RIPEMD160

RIPEMD是一种加密哈希函数，输出为160位bit。

## Base58

Base58编码相较于Base64编码，不使用数字0，大写字母O，大写字母I，小写字母l，符号+、/。

## 女巫攻击

女巫攻击即Sybil Attack。在比特币中由于PoW共识机制是根据算力来竞争记账权的，恶意节点产生再多的账户也没用。

## 分叉攻击

分叉攻击即Forking Attack。在区块链中间的某个区块插入区块来回滚已经发生的交易。
